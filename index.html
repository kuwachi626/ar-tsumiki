<!DOCTYPE html>
<html lang="en">
<head>
	<title>three.js ar - dragging</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
	<link type="text/css" rel="stylesheet" href="main.css">
</head>
<body>

<div id="info">
	<a href="https://threejs.org" target="_blank" rel="noopener">three.js</a> ar - dragging
</div>

<!-- Import maps polyfill -->
<!-- Remove this when import maps will be widely supported -->
<script async src="https://unpkg.com/es-module-shims@1.3.6/dist/es-module-shims.js"></script>

<script type="importmap">
{
	"imports": {
		"three": "https://code4fukui.github.io/three.js/build/three.module.js",
		"three/addons/": "https://code4fukui.github.io/three.js/examples/jsm/"
	}
}
</script>

<script type="module">
import * as THREE from 'three';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
import { ARButton } from 'three/addons/webxr/ARButton.js';

let container;
let camera, scene, renderer;
let controller1, controller2;

let raycaster;

const intersected = [];
const tempMatrix = new THREE.Matrix4();

let group;

init();
animate();

function init() {
	container = document.createElement('div');
	document.body.appendChild(container);

	scene = new THREE.Scene();

	camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 10);
	camera.position.set(0, 0, 3);

	const controls = new OrbitControls(camera, container);
	controls.minDistance = 0;
	controls.maxDistance = 8;

	scene.add(new THREE.HemisphereLight(0x808080, 0x606060));

	const light = new THREE.DirectionalLight(0xffffff);
	light.position.set(0, 6, 0);
	scene.add(light);

	group = new THREE.Group();
	scene.add(group);

	const geometries = [
		new THREE.BoxGeometry(1.6, 0.9, 0.1),
		new THREE.BoxGeometry(0.2, 0.2, 0.2),
		new THREE.ConeGeometry(0.2, 0.2, 64),
		new THREE.CylinderGeometry(0.2, 0.2, 0.2, 64),
		new THREE.CylinderGeometry(0.05, 0.05, 2, 64),
		new THREE.IcosahedronGeometry(0.2, 8),
		new THREE.TorusGeometry(0.2, 0.04, 64, 32)
	];

	const grayscale = true; // false;
	for (let i = 0; i < 50; i++) {
		const geometry = geometries[Math.floor(Math.random() * geometries.length)];
		const getColor = () => {
			if (grayscale) {
				const nc = (Math.random() * 0x100) >> 0;
				const color = (nc << 16) | (nc << 8) | nc;
				return color;
			}
			return Math.random() * 0x1000000;
		};
		const material = new THREE.MeshStandardMaterial({
			color: getColor(),
			roughness: 1.0,
			metalness: 0.0,
			transparent: true,
			opacity: 0.85,
		});

		const object = new THREE.Mesh(geometry, material);

		object.position.x = Math.random() * 4 - 2;
		object.position.y = Math.random() * 4 - 2;
		object.position.z = Math.random() * 4 - 2;

		object.rotation.x = Math.random() * 2 * Math.PI;
		object.rotation.y = Math.random() * 2 * Math.PI;
		object.rotation.z = Math.random() * 2 * Math.PI;

		object.scale.setScalar(Math.random() + 0.5);

		group.add(object);
	}

	//

	renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
	renderer.setPixelRatio(window.devicePixelRatio);
	renderer.setSize(window.innerWidth, window.innerHeight);
	renderer.outputEncoding = THREE.sRGBEncoding;
	renderer.xr.enabled = true;
	container.appendChild(renderer.domElement);

	document.body.appendChild(ARButton.createButton(renderer));

	// controllers

	controller1 = renderer.xr.getController(0);
	controller1.addEventListener('selectstart', onSelectStart);
	controller1.addEventListener('selectend', onSelectEnd);
	scene.add(controller1);

	controller2 = renderer.xr.getController(1);
	controller2.addEventListener('selectstart', onSelectStart);
	controller2.addEventListener('selectend', onSelectEnd);
	scene.add(controller2);

	raycaster = new THREE.Raycaster();

	//
	window.addEventListener('resize', onWindowResize);
}

function onWindowResize() {
	camera.aspect = window.innerWidth / window.innerHeight;
	camera.updateProjectionMatrix();
	renderer.setSize(window.innerWidth, window.innerHeight);
}

function onSelectStart(event) {
	const controller = event.target;
	const intersections = getIntersections(controller);
	const objects = [];
	for (const intersection of intersections) {
		const object = intersection.object;
		object.material.emissive.b = 1;
		controller.attach(object);
		objects.push(object);
	}
	controller.userData.selected = objects;
}

function onSelectEnd(event) {
	const controller = event.target;
	if (controller.userData.selected !== undefined) {
		for (const object of controller.userData.selected) {
			object.material.emissive.b = 0;
			group.attach(object);
		}
		controller.userData.selected = undefined;
	}
}

function getIntersections(controller) {
	tempMatrix.identity().extractRotation(controller.matrixWorld);
	raycaster.ray.origin.setFromMatrixPosition(controller.matrixWorld);
	raycaster.ray.direction.set(0, 0, -1).applyMatrix4(tempMatrix);
	return raycaster.intersectObjects(group.children, false);
}

function intersectObjects(controller) {
	// Do not highlight when already selected
	if (controller.userData.selected !== undefined) return;

	const intersections = getIntersections(controller);
	for (const intersection of intersections) {
		const object = intersection.object;
		object.material.emissive.r = 1;
		intersected.push(object);
	}
}

function cleanIntersected() {
	while (intersected.length) {
		const object = intersected.pop();
		object.material.emissive.r = 0;
	}
}

//
function animate() {
	renderer.setAnimationLoop(render);
}

function render() {
	cleanIntersected();
	intersectObjects(controller1);
	intersectObjects(controller2);
	renderer.render(scene, camera);
}
</script>
</body>
</html>
